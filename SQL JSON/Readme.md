# JSON and SQL Server – A match made in unstructured heaven or Powering your application development 
Since the beginnings of computer systems there has always been a need for those systems to exchange data using a common agreed upon standard. And, naturally, the need to store all that exchanged data in a database. With the proliferation of multiple systems in the enterprise that all needed to talk to each other, this issue only seemed to get worse over time. For schema first systems like SQL Server this was at times challenging as any changes to the formats exchanged often necessitated a change in database objects. 
 
One standard that emerged for exchanging information was a technology called JSON. JSON has exploded in popularity and has quickly become the de facto standard for exchanging information between computer systems, applications, mobile devices, and web services to name just a few. In addition, JSON has simply become the most efficient and flexible way to store unstructured data in places like log files and NoSQL Data Stores such as Azure Document DB. It is a good bet that you are already using JSON somewhere in your application development why not use it in your database too. 
 
With the addition of JSON support to SQL Server you can have the best of both worlds. You have the power, speed, and functionality of an industry leading relational database platform in SQL Server along with the ability to store, query, and modify JSON data side-by-side in a single platform. In addition, because of the way JSON support was implemented in SQL Server you have the ability to quickly build hybrid applications utilizing both relational and unstructured data. 
 
## Where is the JSON Data Type? 
From a functionality perspective there are many parallels with the introduction of JSON to the introduction of XML in SQL Server 2005. However, one of the key difference is with how JSON data is stored vs. how XML data is stored. With XML, a new datatype was introduced. With JSON there is NO new data type. All JSON documents are stored in primitive NVARCHAR data types. All of the functionality related to JSON support is through the use of the functions we reviewed in the previous article operating on documents stored as NVARCHAR data types. 
You might be asking why this is so important.  There are many key benefits to this decision and how it affects your use of JSON Support. 
* Many SQL Server databases have been storing JSON documents in primitive data types for many years. Since the new functionality is introduced through the use of functions, you can simply use this new functionality against your existing data without having to convert 
* There are many applications, drivers, and existing programs with support for SQL Server and they all support the NVARCHAR data type. If a new data type was introduced all of those would have to be updated to support the new type delaying your ability to take advantage of this new functionality. 
* A new data type would require any feature of SQL Server to be changed to work with the new data type. Since everything in SQL Server works with NVARCHAR data, existing functionality within SQL Server can handle and take advantage of JSON data with minimal product changes. 

## 3So what are some ways that I can use this new functionality? 
What this new support for JSON does do is to release the capabilities of storing data in exciting new ways. The ability to build hybrid data solutions with your relational and JSON data side-by-side unleashed new found modes of data functionality. The flexibility of JSON data also puts the database on the same level of functionality with modern applications in handling shifting schemas of data in applications and integrations. While there is an endless stream of ways you can use this new functionality, we are going to focus on two scenarios. 

### Complex and Changing Data Structures 
When an application developer wants to make a change to how data is stored like adding additional data to be stored, if you are in a pure relational world, there are sometimes hurdles to overcome. Depending on how your teams are structured it is possible that teams that manage data schemas and the teams that work on the application are on different teams and may have different priorities or timelines. This may cause needless delays in rolling out new features or making deployments more complicated. 
In addition, your application developers may very well be working with data in an object-oriented structure that is multi-level with multiple properties for each object. So, your application developers are speaking in objects as their native language, so it makes sense to allow for your data layer to speak in familiar terms. In our lab we are going to build out one such example of an application profile for users or our system. 

### Storing Data from 3rd Party Sources 
As any database professional out there can tell you, data environments have grown increasing complex over the years with multiple systems in any given environment. In addition, many of these systems are not even located in your data centers. They might be a SAAS based system, they might be hosted in cloud provider away from your data center like Azure, or they might even be just an information hosting service such as data.gov. 
Regardless of which category the system you need to integrate with fits in, it is very likely that the interface that you interact with on that system is web service based. Almost all systems will provide some type of API layer and in many cases this will be a REST based system which at its heart is based on JSON. So having support for storing JSON side-by-side with your relational data makes this integration much easier and much more flexible. The associated lab will take us through an example of building a system such as this. 

## So how do I work with JSON Data? 
Since there was no new data type introduced to support JSON data, all the functionality is driven through a handful of super powerful functions that allow you to query, modify, and extract information from JSON Text. One of the coolest things about these functions is that these functions can operate on any JSON text. No need to convert to a JSON Document, just pass the JSON text into the function and off you go. 
The pull data from JSON documents we have functions like JSON_VALUE and JSON_QUERY which will return scalar values or JSON objects respectively. Since we are working with blocks of JSON text we will need to be able to validate that we have valid JSON with ISJSON. Lastly, we can make modifications to JSON text using JSON_MODIFY. These functions provide the solid base we need to be able to work with our JSON data right alongside our relational data. 

## What if not all my applications support JSON? 
Change does not always come easy or quick in all environments and we find ourselves wanting to use new features, but always having to worry about how older systems will work. This again is one of the powerful reasons that JSON support in SQL Server is so cool. In addition to the functions above, there are two functions (FOR JSON & OPENJSON) that allow you to control the transition of data from relational to JSON and vice versa. 
The **FOR JSON** clause can be added to any SELECT statement and will format the output of the statement to a JSON document. You can choose AUTO mode to allow SQL Server to create your schema or you can apply path operators to explicitly control the generation of your document. FOR JSON gives us the capability to take our relational data and model it in JSON for consumption by the outside world  
The **OPENJSON** function works in reverse to the FOR JSON clause. The OPENJSON table-valued function will take a JSON Document and provide a rowset view over a JSON Document. This function gives the capability to parse a JSON document and use as a set of rows and columns, even store that data in a relational table if that is needed. 

## What about Indexing, Constraints and other SQL related functionality? 
As we mentioned earlier, one of the key benefits of having all this functionality built on top of the primitive NVARCHAR data give us the ability to do things we would normally do with text strings. We can do things like use a value from a JSON document in an index or setup a check constraint to validate that the incoming data is properly formatted. Want to apply standard security policies such as row level security or return JSON as the result from a UDF or Stored Procedure. You can do all this and more. Since JSON documents are NVARCHAR data types, anything you can do with NVARCHAR you can do with JSON. 

## Conclusion 
The addition of JSON support to SQL Server has opened up a whole new paradigm to what SQL Server is capable of. How can you use this new JSON support to power your modern 
application? Want to get hands on and see what it can do? Then head on over to the accompanying lab to check it out. 

## Done with the intro?
[Start the lab!](labandscripts/lab.md)